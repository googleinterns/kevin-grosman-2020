#!/usr/bin/env bash

#Copyright 2020 Google LLC
#
#Licensed under the Apache License, Version 2.0 (the "License");
#you may not use this file except in compliance with the License.
#You may obtain a copy of the License at
#
#    https://www.apache.org/licenses/LICENSE-2.0
#
#Unless required by applicable law or agreed to in writing, software
#distributed under the License is distributed on an "AS IS" BASIS,
#WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#See the License for the specific language governing permissions and
#limitations under the License.


INPUT_FILE=${1:-input.txt}
PRE_CUJ=$(sed '1q;d' $INPUT_FILE)
POST_CUJ=$(sed '2q;d' $INPUT_FILE)
NUM=$(sed '3q;d' $INPUT_FILE)
RECORD=$(sed '4q;d' $INPUT_FILE)
if [ "$RECORD" != "r" ] 
then 
	RECORD="n"
fi

OUTPUT_FILE="/tmp/time_data.txt"
echo "" > $OUTPUT_FILE


#replace other single quotes by the one recognized by the test
PRE_CUJ=${PRE_CUJ//\‘/\'}
PRE_CUJ=${PRE_CUJ//\’/\'}
POST_CUJ=${POST_CUJ//\‘/\'}
POST_CUJ=${POST_CUJ//\’/\'}

#use escape char to allow special characters (which would terminate the argument in the am instrument command or do other undesirable things).
SpecialChars=(";"  "'" "&" "%" "(" ")" "^" "#" "@" "!" "+")
for char in ${SpecialChars[@]}; do
	exp="\\${char}"
	PRE_CUJ=${PRE_CUJ//$exp/\\$char}
	POST_CUJ=${POST_CUJ//$exp/\\$char}
done
# Wrap strings in \" to allow for spaces within them. 
PRE_CUJ="\\\"$PRE_CUJ\\\""
POST_CUJ="\\\"$POST_CUJ\\\""

adb logcat -c

./gradlew installDebugAndroidTest

if [ "$RECORD" = "r" ] 
then 
	RECSTART=$(( $(adb shell date '+%s%N') / 1000000))
	adb shell "screenrecord /sdcard/test.mp4" &
	PID=$!
fi 

cmd="adb shell am instrument -w -e class com.example.firstapp.UserCujTest#userIterateCuj -e pre $PRE_CUJ -e post $POST_CUJ -e iters $NUM -e rec $RECORD com.example.firstapp.test/androidx.test.runner.AndroidJUnitRunner"
eval $cmd

if [ "$RECORD" = "r" ] 
then 
	kill $PID 
	adb pull sdcard/test.mp4 
	adb pull sdcard/test.mp4  #for some reason, the first pull sometimes doesn't always get the "moov" atom, which we need. Pulling twice seems to always do the trick...
	CUJSTART=$(adb logcat -s "clip_start" -v raw -d | sed -n -e '/^1/p')
	CUJEND=$(adb logcat -s "clip_end" -v raw -d | sed -n -e '/^1/p')
	CUTAT=$((CUJSTART - RECSTART - 2000)) #2000 millisecond buffer in recording before first action is performed
	LENGTH=$((CUJEND - RECSTART + 200)) #200 millisecond buffer in recording after the termination action view is located
	./formatTime "$CUTAT"	
	CUTATFORMAT=$(cat /tmp/time.txt)
	./formatTime "$LENGTH"	
	LENGTHFORMAT=$(cat /tmp/time.txt)
	#forces key frames at the positions at which we'd like to cut, then makes cuts at those positions and dumps output in clip0.mp4, clip1.mp4, clip2.mp4
	cmd="ffmpeg -i test.mp4 -force_key_frames:v $CUTATFORMAT,$LENGTHFORMAT -acodec copy -map 0 -f segment -segment_times $CUTATFORMAT,$LENGTHFORMAT -reset_timestamps 1 -y temp%d.mp4"
	eval $cmd
	mv temp1.mp4 median_clip.mp4
fi 



echo "----------------------------------------------" > $OUTPUT_FILE 
echo "ACTION DURATIONS:" >> $OUTPUT_FILE 
echo "" >> $OUTPUT_FILE 
(adb logcat -s "iterations-actions" -v raw -d | sed -n -e '/^ITERATION/p') >> $OUTPUT_FILE 
echo "" >> $OUTPUT_FILE 
(adb logcat -s "averages-actions" -v raw -d | sed -n -e '/^AVERAGE/p') >> $OUTPUT_FILE 
echo "" >> $OUTPUT_FILE 
echo "----------------------------------------------" >> $OUTPUT_FILE 
echo "TIME STAMPS:" >> $OUTPUT_FILE 
echo "" >> $OUTPUT_FILE 
(adb logcat -s "iterations-stamps" -v raw -d | sed -n -e '/^ITERATION/p') >> $OUTPUT_FILE 
echo "" >> $OUTPUT_FILE 
(adb logcat -s "averages-stamps" -v raw -d | sed -n -e '/^AVERAGE/p') >> $OUTPUT_FILE 
echo "" >> $OUTPUT_FILE 
echo "----------------------------------------------" >> $OUTPUT_FILE 
echo "MEDIAN:" >> $OUTPUT_FILE 
echo "" >> $OUTPUT_FILE 
(adb logcat -s "median" -v raw -d | sed -n -e '/^MEDIAN/p') >> $OUTPUT_FILE 

